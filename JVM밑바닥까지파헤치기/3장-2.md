## GC를 측정하는 지표

- 처리량
- 지연 시간
- 메모리 사용량

- 보통 세 지표 모두 뛰어난 성능을 내는 GC는 없고, 두 가지 정도는 달성할 수 있다.
- 메모리를 늘리면 지연 시간에 악영향을 준다. 힙 메모리 1TB를 처리하고자 한다면, 1GB를 청소할 때보다 오래 걸린다.
- 이에 따라 지연시간이 가장 중요한 성능 지표가 되었다.

## 셰넌도어

셰넌도어는 G1을 계승하여 만든 GC로 힙 레이아웃이 비슷하며, 여러 단계에 공통점이 있다.

- G1 과의 차이점
    1. 동시 모으기를 지원한다. G1은 여러 스레드를 활용해 모으기 단계를 병렬로 수행하지만, 사용자 스레드와 동시에 수행할 수는 없다.
    2. JDK21까지 세대 단위 컬렉션을 사용하지 않는다. 따라서 성능적인 관점에서 약간의 저하가 있다.
    3. 메모리와 컴퓨팅 자원을 많이 사용하는 기억 집합 대신 연결 행렬을 통해 리전 간 참조 관계를 기록한다.

1. 최초 표시 (STW)
    1. GC루트에서 직접 참조하는 객체들에 표시한다.
2. `동시 표시`
    1. 객체 그래프를 타고 힙을 탐색하며 도달 가능한 모든 객체를 표시한다. 이 단계에서 사용자 스레드는 동시에 수행된다.
3. 최종 표시 (STW)
    1. 모든 표시를 완료하고, 회수 가치가 큰 리전들을 추려 회수 집합을 생성한다.
4. 동시 청소
    1. 살아 있는 객체가 하나도 없는 리전을 청소한다.
5. `동시 이주`
    1. 회수 집합 안에 살아 있는 객체들을 다른 빈 리전으로 복사한다. 이 때 사용자 스레드와 동시에 실행된다.
    2. 읽기장벽과 포워딩 포인터를 이용한다.
6. 최초 참조 갱신 (STW)
    1. 이주 단계에서 객체를 복사한 다음, 힙에서 옛 객체를 가르키는 모든 참조 포인터를 수정한다.
7. `동시 참조 갱신`
    1. 참조 갱신을 실제로 시작하며 사용자 스레드와 동시에 수행한다.
    2. 객체 그래프를 탐색할 필요 없이, 물리 메모리 주소의 순서대로 참조 타입을 선형 검색하여 이전 값을 새로운 값으로 수정한다.
8. 최종 참조 갱신
    1. 참조 갱신이 끝난다면 GC루트 집합의 참조도 갱신한다.
9. 동시 청소
    1. 회수 집합의 모든 리전에는 살아있는 객체가 남아 있지 않으므로 동시청소한다.

### 포워딩 포인터

- 기존에는 주로 이동될 객체의 원래 메모리에 메모리 보호 트랩을 설정해 동시 이주 구현
- 원래의 객체 레이아웃 구조 상단에 참조 필드를 하나 추가한다. 동시 이주가 아닌 경우에는 참조 필드가 객체 자신을 가리킨다.
- 포인터 하나의 값만 수정하면 된다는 이점이 있다.

- 스레드들의 경쟁에 직면할 수 밖에 없다.

### 이후 개선

- 로드 참조 장벽
- 포워딩 포인터를 객체 헤더에 통합
- 스택 워터마크를 활용한 스레드 스택 동시 처리

## ZGC

ZGC는 오라클이 개발한 저지연 가비지 컬렉터이다. JDK11에 실험 버전으로 탑재되었고, JDK 15에 정식 버전이 들어갔다. JDK 21부터는 신세대와 구세대를 구분해 처리하는 세대 구분 ZGC가 추가되었다.

- ZGC는 세대 구분 없이 리전 기반 메모리 레이아웃을 사용한다. 낮은 지연 시간을 최우선 목표로 한다.
- 동시 마크-컴팩트 알고리즘을 구현하기 위해 읽기 장벽, 컬러 포인터,메모리 다중 매핑 기술을 이용한다.

### 메모리 기반 레이아웃

G1처럼 메모리를 리전기반으로 나누지만 차이가 있다. ZGC의 리전은 동적으로 생성/파괴 된다. (Page, ZPage라고 표기하기도 한다.) 그뿐 아니라 크기도 동적으로 달라진다.

- 소리전 : 2Mb로 고정되며, 256kb미만 작은 객체를 담는다.
- 중리전 : 32Mb로 고정되며, 256kb이상, 4Mb미만 객체를 담는다.
- 대리전 : 크기가 동적으로 변할 수 있다. 단 2Mb의 배수여야 한다. (4Mb 이상의 큰 객체용 공간이다.) 대리전은 하나의 큰 객체만 담는다.

### 병렬 모으기와 컬러 포인터

ZGC를 상징하는 설계는 바로 컬러 포인터 기술(태그 포인터, 버전 포인터)이다. 가비지 컬렉터나 가상 머신 자체에서만 이용하는 추가데이터를 객체에 저장하고 싶을 때 ZGC이전에는 주로 객체 헤더에 필드를 추가했다.

ZGC에서는 포인터 자체에 소량의 추가 정보를 저장한다. 따라서 객체에 직접 도달할 필요가 없다.

### ZGC의 동작 방식

ZGC의 동작은 크게 네 단계로 나뉜다. 네 단계 모두 사용자 스레드와 동시에 실행되지만, 사이에 일시적으로 사용자 스레드를 정지시키는 작업이 있다.

1. 표시 단계
    1. GC루트를 찾아 표시한다.
2. 동시 표시
    1. 객체 그래프를 탐색하며 도달 가능성을 분석한다. (ZGC는 이를 컬러포인터에 표시한다.)
3. 동시 재배치 준비
    1. 청소해야 할 리전들을 선정하며 재배치 집합을 만든다.
4. 동시 재배치
    1. 재배치는 ZGC의 핵심 단계이다. 이 단계에서 재배치 집합에 속한 기존 객체를 새로운 리전으로 복사한다.
    2. 포워드 테이블에 옛 객체와 새 객체의 이주 정보를 저장한다. 컬러 포인터 덕분에 객체가 재배치 집합에 속하는지 참조만 보고 알 수 있다.
5. 동시 재매핑
    1. 재매핑이란 힙 전체에서 재배치 집합에 있는 옛 객체들을 향하는 참조 전부를 갱신하는 것이다. 이는 급하게 진행되지 않아도 된다.

## **세대 구분 ZGC**

세대 구분 ZGC(generational ZGC)는 ZGC를 확장하여 신세대와 구세대를 구분하도록 했다. 

세대를 구분해서 얻는 가장 큰 이점은 물론 수명이 짦은 젊은 객체들을 더 자주 회수한다.

적용된 기술 일부

- 다중 매핑 메모리 제거
- 이중 버퍼를 활용한 기억 집합 관리
- 밀집도 기반 리전 처리
- 거대 객체 처리
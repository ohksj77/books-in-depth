## JVM의 메모리 관리의 장단점

- **장점:** 자동 메모리 관리 메커니즘 덕에 메모리 할당과 해제에 신경을 크게 쓰지 않아도 됨
- **단점:** 메모리 관리의 통제권을 위임했기에 문제가 터지면 가상 머신의 메모리 관리 방식을 잘 이해하지 못하면 해결하기 어려움

## 런타임 데이터 영역

- 런타임 데이터 영역은 몇가지 영역으로 구분되며 각각의 목적과 생성/삭제 시점이 존재

### 런타임 데이터 영역

- **모든 스레드가 공유:** 메서드 영역 (런타임 상수 풀 포함), 힙
- **스레드별 데이터 영역:** 가상 머신 스택, 네이티브 메서드 스택, 프로그램 카운터(pc) 레지스터

### 프로그램 카운터

**프로그램 카운터 레지스터 개요**

- 작은 메모리 영역, 현재 실행 중인 스레드의 “바이트코드 줄 번호 표시기” 와 같음
- 바이트 코드 인터프리터는 이 카운터의 값을 바꿔 다음에 실행할 바이트코드 명령어를 선택하는 식으로 동작
- 프로그램 제어 흐름, 분기, 순환, 점프 등을 표현
- 예외 처리, 스레드 복원 등의 모든 기본 기능이 이 표시기를 활용해 이루어짐

**프라이빗 메모리에 저장**

- JVM에서의 멀티스레딩은 CPU 코어를 여러 스레드가 교대로 사용
- 특정 시각에 각 코어는 한 스레드의 명령어만 실행
- 이전에 실행하던 지점으로 복원하려면 스레드 별로 고유한 프로그램 카운터 필요
- 스레드들이 서로 영향을 주지 않는 독립된 영역(프라이빗 메모리)에 저장

* 프로그램 카운터 메모리 영역은 JVM 명세에서 OutOfMemoryError 조건이 명시되지 않은 유일한 영역

### 자바 가상 머신 스택

**각 메서드가 호출될 때마다 스택 프레임을 만들어 다음 항목들을 저장**

- 지역 변수 테이블
- 피연산자 스택
- 동적 링크
- 메서드 반환값

**지역 변수 테이블에 저장되는 정보들**

- 기본 데이터 타입
- 객체 참조
- 반환 주소 타입

**메서드 변수 슬롯 개수 불변성**

- 자바 메서드는 스택 프레임에서 지역 변수용으로 할당받아야 할 공간의 크기(변수 슬롯 개수)가 이미 결정되어 있음
    - 메서드 실행 중에 변하지 않음

* 스택을 확장하려는 시점에 여유 메모리가 없다면 OutOfMemoryError 발생

### 네이티브 메서드 스택

- 네이티브 메서드를 실행할 때 사용

### 자바 힙

- 자바 애플리케이션이 사용할 수 있는 가장 큰 메모리
- 객체 인스턴스를 저장, 거의 모든 객체 인스턴스가 이 영역에 할당

저장의 연속성

- 자바 힙은 물리적으로 떨어진 메모리에 위치해도 상관 없으나 논리적으로 연속되어야 함
- 큰 객체 (Humongous Object?)는 물리적으로도 연속된 메모리 공간을 사용하도록 구현
    - 저장 효율을 높이고 구현 로직을 단순하게 유지하기 위함

### 메서드 영역

- 모든 스레드가 공유
- 타입 정보, 상수, 정적 변수, JIT 컴파일러가 컴파일한 코드 캐시 등을 저장

**JDK 버전에 따른 변화**

- JDK 7 에서 “영구 세대” 에서 저장되던 문자열 상수와 정적 변수 등의 정보가 자바 힙(메타스페이스)으로 옮겨짐
- JDK 8 에서 영구 세대라는 개념을 완전히 지우고 네이티브 메모리에 메타스페이스를 구현

**메서드 영역의 모든 데이터가 영구적인 것은 아님**

- 회수 대상이 대부분 상수 풀과 타입이라서 회수 효과가 매우 작음
- 타입은 회수 조건이 까다로움

### 런타임 상수 풀

- 클래스 버전, 필드, 메서드, 인터페이스 등 클래스 파일에 포함된 설명 정보 저장
- 컴파일타임에 생성된 리터럴과 심벌 참조 저장

**가상 머신이 클래스 파일을 로드해 실행하기 위한 제약**

- 각 바이트에는 명세가 요구하는 데이터가 들어 있어야 함
- 런타임 상수 풀은 이러한 제약은 없음

동적이라는 특징

- 상수는 꼭 컴파일타임이 아닌 런타임에도 추가될 수 있음
    - `String.intern()`

### 다이렉트 메모리

- 가상 머신 런타임에 속하지 않으며, JVM 명세에도 정의되지 않았지만, `OutOfMemoryError` 의 원인이 될 수 있음

NIO 와 다이렉트 메모리

- NIO 는 힙이 아닌 네이티브 함수 라이브러리(다이렉트 메모리)를 활용
- 힙과 네이티브 힙 사이에서 데이터를 복사하는 과정이 없어 일부 시나리오에서 성능이 개선되기에 도입

## 핫스팟 가상 머신에서의 객체 들여다보기

- 메모리 모델 (만들어지는 시기, 저장되는 상세 구조, 접근 방식 등) 을 알아보자

### 객체 생성

**객체 인스턴스 생성 시 힙 메모리에 할당**

1. Java의 new 명령에 해당하는 바이트코드를 만남
    - 이 명령의 매개 변수가 상수 풀 안의 클래스를 가리키는 심벌 참조인지 확인
2. 심벌 참조가 뜻하는 클래스가 로딩, 해석, 초기화 되었는지 확인
    - 준비되지 않은 클래스라면 로딩부터 수행
3. 로딩된 클래스라면 새 객체를 담을 메모리를 할당
    - 메모리 크기는 클래스 로딩 시 완벽하게 알 수 있음
4. 자바 힙에 특정 크기의 메모리 블록을 잘라서 할당

**메모리 할당**

- **자바 힙이 완벽히 규칙적이라면)** 여유 공간 쪽으로 객체 크기 만큼 이동(포인터 밀치기)
    - 이 방법은 이상적이지만 어려워서 아래 방법 활용
- **나머지)** 가용 메모리 블록들을 목록(여유 목록)으로 관리하며 충분한 공간을 찾아 할당한 후 목록 갱신

**멀티스레딩 환경에서의 메모리 할당 → 가능한 두 가지 방법**

1. CAS 연산과 실패 시 재시도로 원자적 실행 보장
2. 스레드마다 다른 메모리 공간 할당

**메모리 할당 후 초기화**

- 메모리 할당 이후 가상 머신은 할당 받은 공간을 0으로 초기화 (객체 헤더 제외)
- 자바 코드에서 객체 인스턴스 필드를 초기화하지 않고 사용할 수 있는 이유
    - int = 0, boolean = false 를 의미?

**각 객체에 필요한 설정**

- [어느 클래스의 인스턴스인지, 메타 정보를 어떻게 찾는지, GC 세대 나이는 얼마인지] 등의 정보를 “객체 헤더”에 설정

### 객체의 메모리 레이아웃

**객체 해더**

- 객체의 런타임 데이터
    - **마크 워드 저장 ⇒** 해시 코드, GC 세대 나이, 락 상태 플래그, 스레드가 점유하고 있는 락들, 편향된 스레드의 아이디, 편향된 시각의 타임스탬프 등
- 배열의 경우 배열의 길이 또한 저장

**인스턴스 데이터**

- 필드 관련 내용
- 부모 클래스 유무
- 부모 클래스에서 정의한 모든 필드

**정렬 패딩**

- 특별한 의미 없이 자리를 확보하는 역할만 수행
- 인스턴스 데이터가 8바이트 정수배가 안되면 패딩으로 채움

### 객체에 접근하기

핸들 방식

- 객체 접근 → 핸들 풀의 객체 인스턴스 데이터를 가리키는 포인터 → 실제 객체 타입 데이터
- 자바 힙에 핸들 풀이 따로 존재
- 안정적인 핸들의 주소가 저장됨
    - 객체 위치가 바뀌는 상황에서도 참조 자체는 손댈 필요가 없음

다이렉트 포인터 방식

- 객체 접근 → 실제 객체 타입 데이터
- 성능상 이점

## OutOfMemoryError 예외

**예외 예시**

1. 멈추지 않고 반복하며 계속해서 리스트에 object 를 추가하는 경우 자바 힙에서 `OutOfMemoryError`가 발생
2. 스레드가 요구하는 스택 깊이가 가상 머신이 허용하는 최대 깊이보다 크면 `StackOverflowError`를 던짐
3. 가용 메모리가 부족해 스택을 더 확장할 수 없다면 `OutOfMemoryError`가 발생

등등…

**힙 덤프를 확인하여 이슈의 원인을 파악하고 대응하자!!**
# 5장. 최적화 사례 분석 및 실전

## 사례 분석

### 대용량 메모리 기기 대상 배포 전략

### 배경

- 다음과 같은 스펙의 서버를 운영해 본 결과 서버 실행 효율이 기대에 못 미치고, 장시간 응답하지 않는 일도 발생
    - 64bit, CentOS 5.4
    - JVM 힙 크기 12G

### 원인

- 패러렐 컬렉터의 가비지 컬렉션 때문에 최장 14초 까지 일시 중지
    - 페러렐 컬렉터는 처리량에 중점을 두고 있음
- 힙 메모리를 너무 크게 잡아 회수하고 재활용하는 데 너무 오래 걸리는 것이 문제

- 이전 시스템에서는 2G, 32bit 시스템이였지만, 현 상황보다 응답시간이 빨랐다.

### 해결 방법

1. 가상 인스턴스 하나에 거대한 자바 힙 메모리를 관리한다.
- ZGC나 셰넌도어와 같은 저지연 가비지 컬렉터를 선택해 해결해볼 수 있다.
- 전체 GC를 제어해서 사용자가 없는 시간대에 전체 GC를 수행하도록 스케줄링할 수도 있다.
    - GC빈도를 제어하고자 한다면 구세대가 안정되어야 한다. 너무 오래 생존하는 객체가 없어야 하며 특히 거대 객체가 대량으로 만들어지면 위험하다.

1. 가상 머신 여러개를 논리적 클러스터로 구성한다.
- 이런 논리 클러스터를 통한 배포 및 CMS 가비지 컬렉터를 활용해 응답속도를 높일 수 있다.

### 클러스터 간 동기화로 인한 메모리 오버플로

- 다음과 같은 환경에서 메모리 오버플로 문제 발생
    - 8G Memory, 32Bit

- 세션 동기화는 일어나지 않았지만 일부 데이터를 공유하고 있었다.
- 성능 이슈로 글로벌 캐시를 구축한 이후에는 메모리 오버플로가 가끔 발생했다.
- 메모리 누수 의심하여 확인해보니 NAKACK 객체가 많이 발견되었다.
- 네트워크가 데이터 전송량을 다 처리하지 못하여 재전송되며 계속 데이터가 메모리에 쌓이다가 오버플로가 발생한 것이었다.

### 힙 메모리 부족으로 인한 오버플로 오류

- 다음과 같은 환경에서 오버플로가 발생했으며 메모리가 부족해서 힙덤프를 생성 못함
    - Jetty, i5, 4G Memory, 32Bit

- 힙덤프를 보지 못하여, jstat을 활용해 상황을 지켜봤더니 가비지 컬렉션은 자주 일어나지 않았다.
- 또한 에덴, 생존자 공간, 구세대, 신세대 그리고 힙 메모리까지 모두 안정적이였다.
- 시스템 로그를 출력해 보았을 때 다이렉트 메모리가 부족하여 메모리 오버플로가 발생한 것을 볼 수 있었다.
    - 다이렉트 메모리도 GC 대상이다. 힙의 구세대가 꽉 차서 전체 GC가 수행되기만 기다려야 한다.

- 다이렉트 메모리 매개 변수로 크기를 조절할 수 있다.

### **시스템을 느려지게 하는 외부 명령어**

- 다음과 같은 환경에서 동시성 스트레스 테스트를 수행하자 응답 속도가 지나치게 느려졌다.
    - 프로세서 4개가 장착된 솔라리스 10 시스템
    - 미들웨어: 글래스피시

- 셸 스크립트를 실행하는 코드로인해 fork() 시스템 콜을 외부에서 호출할 수 있었다.
- 사용자 요청 처리시 시스템 정보가 필요해 외부 셸 스크립트를 실행하도록 작성하면 프로세스가 지나치게 많이 생성되어 자원을 매우 많이 소비하게 된다.
- 셸 스크립트 대신 필요한 정보를 Java API로 가져오도록 고치면 시스템이 정상적으로 작동한다.

### 서버 가상 머신 프로세스 비정상 종료

- 다음과 같은 환경에서 이슈 발생
    - 듀얼 프로세서, 8GB 메모리의 컴퓨터 2대에 각 웹로직 3개씩 구동

- 테스트 시 타임아웃이 발생한다.
- 웹 서비스 호출을 내부적으로 비동기로 수행하고 있었으며, 호출에 대한 응답이 제때 오지 않아 대기 중인 스레드와 소켓 연결이 점점 많아지며 가상 머신 프로세스 비정상 종료.

### 부적절한 데이터 구조로 인한 메모리 과소비

- 64바이트 자바 가상 머신, 파뉴 + CMS 컬렉터 조합

- 10분단위로 80Mb의 파일을 메모리로 읽어야 하며, 100만 개 이상의 `HashMap<Long, Long>`객체를 만들어 냈다.
- 마이너 GC가 100만 개 넘는 객체를 검사하느라 STW가 500밀리초로 늘어났다.
- 계산해보면, 메모리 사용량 중 유효 데이터의 비율은 겨우 18%다. 정말 낮은 효율이다.

### 윈도우 가상 메모리로 인한 긴 일시 정지

- GUI 데스크톱 프로그램에서 이슈 발생

- 거짓 양성 데이터가 자주 섞여 들어오는 문제 발생
    - 1분 간격으로 로그 출력 없이 일시 정지 상태가 됨을 발견
    - 가비지 컬렉션이 이유였다. 가끔씩 1분 가까이 길게 가비지 컬렉션이 실행됐다.
- 창을 최소화하면 작업 메모리가 디스크로 스왑되며 이 상태에서 가비지 컬렉션을 하려면 스왑된 데이터를 메모리로 다시 불러와야 한다.

- 창을 최소화할 때에도 작업 메모리를 유지하여 해결

### 안전 지점으로 인한 긴 일시 정지

- HBase 클러스터 환경
- JDK8 , G1 컬렉터

- HBase 연결 타임아웃 초기화 기능이 문제였다.

- 클러스터에는 맵리듀스와 스파크 태스크의 연결이 다수 있었고, 태스크 각각이 다수의 Mapper, Reducer, Executer를 동시에 시작시켰다.
- 그리고 그 각각은 다시 HBase 클라이언트로 동작하면서 동시에 엄청난 수의 연결을 만들어 냈다.
- 이 연결을 초기화하는 순환문의 루프 변수가 int 타입이었기 때문에, 즉 카운티드 루프였기 때문에 핫스팟이 순환문 안에 안전 지점을 설정하지 않은 것이다.

- 문제의 루프 변수 타입을 long으로 변경하면 해결된다.

## 이클립스 구동 시간 줄이기

- 다음과 같은 작업을 수행할 수 있다.
    - 클래스 로딩 시간 최적화
    - 컴파일 시간 최적화
    - 메모리 설정 최적화
    - 적절한 컬렉터 선택으로 지연 시간 단축
